"""
N8N Integration API Routes
Handles file uploads and data exchange with N8N workflows
"""
from fastapi import APIRouter, Depends, File, HTTPException, UploadFile, Query
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
import os
from datetime import datetime
from typing import Optional

from app.utils.deps import get_db
from app.models.absence import PDFAbsence
from app.utils.cache import redis_cache
from app.services.ai_scoring_service import update_student_scores

router = APIRouter()


@router.post("/calculate-scores")
async def calculate_ai_scores(
    class_name: Optional[str] = Query(None, description="Filter by class (e.g., DSI2)"),
    db: Session = Depends(get_db)
):
    """
    Calculate AI attendance scores for students based on REAL attendance data.
    
    This endpoint should be called by N8N Workflow 4 to:
    1. Query actual attendance records from database
    2. Calculate dynamic scores (0-100) based on presences/absences
    3. Generate AI justification text in French
    4. Update students table with new scores
    5. Invalidate cache for immediate frontend update
    
    Args:
        class_name: Optional filter to calculate only for specific class
    
    Returns:
        {
            "status": "success",
            "updated": 15,
            "class": "DSI2" or "all"
        }
    """
    try:
        # Calculate and update scores
        updated_count = update_student_scores(class_name, db)
        
        # Clear cache so frontend shows updated scores immediately
        if redis_cache and redis_cache.available():
            redis_cache.invalidate(prefix="students:")
        
        return {
            "status": "success",
            "updated": updated_count,
            "class": class_name or "all",
            "message": f"Successfully calculated AI scores for {updated_count} student(s)"
        }
    
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error calculating scores: {str(e)}"
        )


@router.post("/cache/invalidate")
async def invalidate_cache(payload: dict = None):
    """
    Invalidate Redis cache after N8N updates data.
    
    N8N should call this endpoint after:
    - Workflow 4: Updating student AI scores
    - Workflow 5: Uploading new PDFs
    
    This ensures frontend gets fresh data immediately.
    """
    if redis_cache and redis_cache.available():
        # Clear all student-related cache
        redis_cache.invalidate(prefix="students:")
        # Clear PDF cache if needed
        redis_cache.invalidate(prefix="pdfs:")
        
        return {
            "status": "success",
            "message": "Cache invalidated successfully",
            "cleared": ["students", "pdfs"]
        }
    
    return {
        "status": "success",
        "message": "Cache not enabled, no action needed"
    }


@router.post("/upload")
async def upload_pdf_from_n8n(
    file: UploadFile = File(...),
    db: Session = Depends(get_db)
):
    """
    Upload PDF generated by N8N Workflow 5 (Daily absence summary).
    
    N8N sends the PDF here after generating it from Gotenberg.
    Expected filename format: absences_FS202_2025-12-21.pdf
    """
    if not file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="Only PDF files are allowed")
    
    # Create upload directory if it doesn't exist
    upload_dir = "/app/storage/n8n_pdfs"
    os.makedirs(upload_dir, exist_ok=True)
    
    # Save file
    file_path = os.path.join(upload_dir, file.filename)
    with open(file_path, "wb") as f:
        content = await file.read()
        f.write(content)
    
    # Parse filename to extract class and date
    # Format: absences_FS202_2025-12-21.pdf
    try:
        parts = file.filename.replace('.pdf', '').split('_')
        if len(parts) >= 3:
            class_name = parts[1]
            date_str = parts[2]
        else:
            raise ValueError("Invalid filename format")
    except:
        # Fallback if parsing fails
        class_name = "unknown"
        date_str = datetime.now().strftime("%Y-%m-%d")
    
    # Record in database
    pdf_record = PDFAbsence(
        class_name=class_name,
        date=date_str,
        pdf_path=file_path
    )
    db.add(pdf_record)
    db.commit()
    
    # Invalidate cache so frontend gets fresh data immediately
    if redis_cache and redis_cache.available():
        redis_cache.invalidate(prefix="pdfs:")
    
    return {
        "status": "success",
        "filename": file.filename,
        "path": file_path,
        "class": class_name,
        "date": date_str,
        "cache_cleared": True
    }


@router.get("/pdfs/recent")
async def get_recent_pdfs(
    limit: int = 10,
    db: Session = Depends(get_db)
):
    """
    Get list of recent PDF reports.
    
    Used by admin dashboard to show available reports.
    """
    pdfs = db.query(PDFAbsence).order_by(
        PDFAbsence.created_at.desc()
    ).limit(limit).all()
    
    return [
        {
            "id": pdf.id,
            "class": pdf.class_name,
            "date": pdf.date,
            "pdf_path": pdf.pdf_path,
            "created_at": pdf.created_at
        }
        for pdf in pdfs
    ]


@router.get("/pdfs/download/{pdf_id}")
async def download_pdf(
    pdf_id: int,
    db: Session = Depends(get_db)
):
    """
    Download PDF file by ID.
    
    Returns the actual PDF file for browser download.
    """
    pdf = db.query(PDFAbsence).filter(PDFAbsence.id == pdf_id).first()
    
    if not pdf:
        raise HTTPException(status_code=404, detail="PDF not found")
    
    if not os.path.exists(pdf.pdf_path):
        raise HTTPException(status_code=404, detail="PDF file not found on disk")
    
    filename = f"absences_{pdf.class_name}_{pdf.date}.pdf"
    
    return FileResponse(
        pdf.pdf_path,
        media_type="application/pdf",
        filename=filename
    )


@router.get("/pdfs/{class_name}/{date}")
async def get_daily_pdf(
    class_name: str,
    date: str,
    db: Session = Depends(get_db)
):
    """
    Get PDF path for a specific class and date.
    
    Used by admin dashboard to download daily absence reports.
    """
    pdf = db.query(PDFAbsence).filter(
        PDFAbsence.class_name == class_name,
        PDFAbsence.date == date
    ).first()
    
    if not pdf:
        raise HTTPException(status_code=404, detail="PDF not found for this date")
    
    return {
        "class": pdf.class_name,
        "date": pdf.date,
        "pdf_path": pdf.pdf_path,
        "created_at": pdf.created_at
    }
